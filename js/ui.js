// Generated by CoffeeScript 1.8.0
(function() {
  var addMouseCallbacks, bodyClickCb, bodyNode, branchBlurCb, branchChangeCb, branchFocusCb, branchInput, branchInputCb, branchKeyCb, branchSuggestions, clickListener, defaultBranch, dokiboxArtifacts, listElement, mouseOutCb, mouseOverCb, mouseout, mouseover, unfuckHierarchy;

  unfuckHierarchy = function(targetNode, parentNode) {
    switch (targetNode.tagName) {
      case 'SVG':
      case 'svg':
        targetNode = parentNode;
        parentNode = targetNode.parentNode.parentNode;
        break;
      case 'PATH':
      case 'path':
        targetNode = parentNode.parentNode;
        parentNode = targetNode.parentNode.parentNode;
        break;
      case 'DIV':
        switch (targetNode.className) {
          case 'download':
          case 'commit':
            parentNode = targetNode.parentNode.parentNode;
        }
        break;
      default:
        return [false, false];
    }
    return [targetNode, parentNode];
  };

  mouseover = function(ev) {
    var artifact, identity, index, info, lastParent, lastTarget, parentNode, targetNode, _ref, _ref1;
    _ref = unfuckHierarchy(ev.target, ev.target.parentNode), targetNode = _ref[0], parentNode = _ref[1];
    if (targetNode === false) {
      return false;
    }
    _ref1 = this.lastNode || [], lastTarget = _ref1[0], lastParent = _ref1[1];
    if (lastParent === parentNode) {
      clearTimeout(this.mouseOutTimer);
    }
    if (targetNode === lastTarget) {
      return false;
    }
    identity = targetNode.className;
    index = parentNode.id;
    artifact = this.artifacts[this.displayBranch][index];
    info = parentNode.querySelector(".info");
    switch (identity) {
      case 'size':
        info.textContent = artifact.size.text;
        break;
      case 'info':
        info.textContent = artifact.date.alt;
        break;
      case 'commit':
        info.textContent = artifact.file.commitText;
        break;
      case 'download':
        info.textContent = artifact.hash.text;
    }
    return false;
  };

  mouseout = function(ev) {
    var parentNode, targetNode, _ref;
    _ref = unfuckHierarchy(ev.target, ev.target.parentNode), targetNode = _ref[0], parentNode = _ref[1];
    if (targetNode === false) {
      return false;
    }
    this.lastNode = [targetNode, parentNode];
    return this.mouseOutTimer = setTimeout((function(_this) {
      return function() {
        var identity, index, info;
        _this.lastNode = [null, null];
        identity = targetNode.className;
        index = parentNode.id;
        info = parentNode.querySelector(".info");
        return info.textContent = _this.artifacts[_this.displayBranch][index].date.text;
      };
    })(this), 1);
  };

  defaultBranch = "master";

  dokiboxArtifacts = new window.ArtifactParser("https://s3.amazonaws.com/dokibox-builds/", "https://github.com/dokibox/dokibox/", defaultBranch);

  mouseOverCb = (function(_this) {
    return function(ev) {
      return mouseover.call(dokiboxArtifacts, ev);
    };
  })(this);

  mouseOutCb = (function(_this) {
    return function(ev) {
      return mouseout.call(dokiboxArtifacts, ev);
    };
  })(this);

  clickListener = function(build) {
    return build.querySelector('div.download').addEventListener('click', function(ev) {
      build.removeEventListener("mouseover", mouseOverCb, false);
      return build.removeEventListener("mouseout", mouseOutCb, false);
    });
  };

  addMouseCallbacks = function() {
    var build, builds, _i, _len, _results;
    builds = document.querySelectorAll("li.entry");
    _results = [];
    for (_i = 0, _len = builds.length; _i < _len; _i++) {
      build = builds[_i];
      build.addEventListener("mouseover", mouseOverCb, false);
      build.addEventListener("mouseout", mouseOutCb, false);
      _results.push(clickListener(build));
    }
    return _results;
  };

  bodyNode = document.querySelector('body');

  listElement = document.querySelector('ul#builds');

  branchInput = document.querySelector('#branch-input');

  branchSuggestions = null;

  dokiboxArtifacts.fetchListing(function() {
    this.setRange(listElement, [0, 9]);
    branchSuggestions = new window.BranchSuggestions(this.branches, branchInput, function(ev) {
      branchInput.value = ev.target.textContent;
      return branchChangeCb();
    });
    branchInput.value = defaultBranch;
    document.querySelector('#cover').className = 'gone';
    return addMouseCallbacks();
  });

  branchInputCb = function() {
    return branchSuggestions != null ? branchSuggestions.filter(branchInput.value) : void 0;
  };

  branchFocusCb = function() {
    if (branchSuggestions != null) {
      branchSuggestions.show();
    }
    return bodyNode.addEventListener('click', bodyClickCb, false);
  };

  bodyClickCb = function() {
    if (document.activeElement !== branchInput) {
      return branchBlurCb();
    }
  };

  branchBlurCb = function() {
    if (branchSuggestions != null) {
      branchSuggestions.hide();
    }
    return bodyNode.removeEventListener('click', bodyClickCb, false);
  };

  branchChangeCb = function() {
    if (dokiboxArtifacts.changeBranch(listElement, branchInput.value)) {
      addMouseCallbacks();
    }
    return branchInput.value = dokiboxArtifacts.displayBranch;
  };

  branchKeyCb = function(ev) {
    switch (ev.keyCode) {
      case 9:
        return branchBlurCb();
    }
  };

  branchInput.addEventListener('input', branchInputCb, false);

  branchInput.addEventListener('focus', branchFocusCb, false);

  branchInput.addEventListener('keydown', branchKeyCb, false);

  branchInput.addEventListener('change', branchChangeCb, false);

}).call(this);
